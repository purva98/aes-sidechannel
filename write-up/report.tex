\documentclass[journal]{ieee_style}

\usepackage{amsfonts}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{url}
\usepackage{array}


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{Power-Based Side-Channel Attack for AES Key Extraction on a ATMega328 controller}

\author{Utsav Banerjee,
        Lisa Ho,
        and Skanda Koppula% <-this % stops a space
\thanks{All authors are with the Department
of Electrical and Computer Engineering, Massachusetts Institute of Technology, Cambridge,
MA, 02139 USA}% <-this % stops a space
\thanks{To contact the authors: \texttt{utsav@mit.edu}, \texttt{lisaho@mit.edu}, and \texttt{skandak@mit.edu}}% <-this % stops a space
\thanks{Manuscript completed for 6.858 Computer Systems Security; completed on December 5, 2015}}


\markboth{6.858 Final Project Report - Fall 2015}%
{Power-Based Side-Channel Attack for AES Key Extraction on the ATMega328 controller}
\maketitle

\begin{abstract}
    We demonstrate extraction of a private-key from Flash program memory on the ATMega328 microcontroller (the controller used on the popular Arduino Genuino/Uno board). We loaded a standard AVR-architecture AES implementation onto the chip and ran this implementation to encrypt 500 randomly chosen plaintexts. By carefully measuring the chips power consumption, we were able to correlate the consumed power with the input plaintexts and key values that might be used to encrypt each AES block, and back-derive the hard-coded key used for encryption. We describe here our test infrastructure for automated power trace collection, an overview of our correlation attack, sanitization of the traces and interesting stumbling blocks encountered during data collection and analysis, and the results of our attack.
\end{abstract}

\begin{IEEEkeywords}
AES, side-channel, power consumption, ATMega328, Correlation Power Analysis
\end{IEEEkeywords}

\section{Introduction}
The recent wave of concern about data privacy has brought attention to the necessity for more broadly adopted encryption algorithms. One of the more popular symmetric-key algorithms, Advanced Encryption Standard (AES), has been the U.S. government standard since 2002 (ISO/IEC 18033-3), and used in a multitude of applications: SSL/TLS protocols \cite{ssl}, Kerberos \cite{kerberos}, and demonstrably secure embedded devices \cite{embedded}. This last application in particular, embedded devices, has seen much growth in recent years, given the advantages of computation on smaller embedded devices: low power, lower system latency, and generally smaller device size.

Small hardware implementations, however, are notoriously vulnerable to a range of side-channel attacks \cite{smalldevice}. Timing, electromagnetic radiation, and power consumption are just three commonly exploited vectors used to leak information about ongoing computations and data on the chip. Knowing that a device architecture is amiable to side-channel exploitation is useful in deciding whether to execute unprotected sensitive computations or store data on devices with similar memory and processor characteristics.

We aim to demonstrate a reasonably realistic side-channel attack on AES on one such embedded device: the ATMega328 microcontroller produced by Atmel. The ATMega328 is the basis for the widely popular development board, Arduino Uno \footnote{Other models of the Arduino, such as the Arduino Mega and Arduino Genuino Micro use ATMega chips as well, that have a similar architecture to the ATMega328. It is possible that this attack could be adapted to those chips as well.}

In section two, we review for the read the theoretical ideas underpinning our attack. In section three, we describe our implementations our hardware setup, power measurement infrastructure, correlation methodologies, instructive problems that we encountered, and overview the structure of our source code. In section four, we describe quantitatively describe the results of our attack.

\section{Preliminaries}
\subsection{Controller Specifications}
The ATMega328 family of chips is an 8-bit microcontroller series with 32 KB of NAND-type flash and 2KB of SRAM. The controller runs off a 16 MHz external clock on the Arduino board. Typical power consumption of the chip ranges from 7 to 12V, with a 20mA current draw, depending on the peripheral and I/O pin usage \cite{atmeldatasheet}. Out attack exploits the NAND-type flash memory architecture that consumes marginally more power when accessing addresses that store bits with lower Hamming weight \footnote{NAND-flash works by charging and recharge the memory cell line} \cite{nandflash}.

The encryption program running on our ATMega328 uses an Arduino-specific port of the \texttt{avr-crypto-lib} by Davy Landman and Bochum Hackerspace \cite{AESLib} \cite{daslabor}. \texttt{AESLib} is one of the more widely-used AES implementations for Arduino, and includes support for ECB and CBC-modes of AES. Our team decided that ECB-mode would be more amiable to a power correlation attack, and correspondingly chose to exploit the library's AES-ECB implementation. We discuss ECB in further depth in section 3.D.

% Discuss AESLib, ATMel, AVR architecture, possibly Flash memory model and vector of attack, give some specs
\subsection{Correlation Power Analysis}
% Briefly explain how CPA works
% sbox, AES is a block cipher that encrypts blocks of plaintext in a number 
Correlation Power Analysis (CPA) is a type of side channel attack that relies on power consumption information. On a high level, CPA attempts to correlate observed power consumption with expected power consumption. To a greater extent than more basic forms of power analysis such as Simple Power Analysis, CPA attacks are able to extract secret keys from noisy data. This requires collecting the power consumption of a device performing encryption over many different plaintexts with the same key. We can then build a power model that contains the expected power consumption of the device performing a particular operation during encryption over the given plaintexts with every possible key. 

In our case, we used CPA against AES encryption. There are several operations during AES that can be good candidates to model power consumption for depending on the hardware implementation. Attacks tend to model power from the first round of AES because it is most clear in this round which bytes of plaintext and key are getting combined. Power analysis tends to target the XOR operation in the \texttt{AddRoundKey} or the SBOX substitution during the \texttt{SubBytes} operation, since these can consume predictable amounts of power. Different implementations use different estimates to correlate power consumption with, most commonly the Hamming Weight of the operation result or the Hamming Distance of the input and output of the operation. These may be correlated with the amount of power consumed because reading a "0" or "1" from memory may require a different amount of power.
 
Using CPA against AES requires collecting the amount of power consumed over hundreds of plaintexts. We then calculate the expected power consumption for each of these plaintexts with every possible key. Trying every possible key with AES is possible because a different byte of the key is used for every byte of the plaintext. This reduces our search space to $2^8$ possibilities for each key byte, which allows us to build a power model that takes every one of these $2^8$ key byte possibilities into account for each byte. 

After building a power hypothesis consisting of the amount of power consumed for each possible plaintext with every possible key byte, we can calculate the correlation coefficients between these expected amounts of power and the amount of power observed during encryption. One advantage of CPA is that we don't need to know exactly when during encryption our targeted operation occurs; we can calculate the correlation coefficient between the power hypothesis and the power trace (collected power consumption over time) at each point of the trace. We then take the key byte that gives us the maximum correlation coefficient as our best guess key byte. Repeating this process 16 times gives us best guesses for all 16 bytes of the key.


\section{Protocols and Procedure}

\subsection{Data Collection Infrastructure}
\begin{itemize}[-]
    \item Discuss trigger with memoery mapped register with assembly sbi instruction, schematic for collection, oscilloscope model/programmer model GPIB with assembly sbi instruction. 
\item Faraday shield metal box
\item fast frames
\end{itemize}

\subsection{Implementation of CPA and Power Model}
- discuss different power models we've tried, faster correlation

\subsection{Instructive Problems Encountered (and Panaceas)}


\begin{itemize}[-]
\item remove difAmp -> increase resistor value -> increase bandwidth?//used to measure current before
\item serial print adds noise
\item averaging to solve dc shift
\item interrupt introduces clock jitter
\item adding nops to prevent asyncronous / delay
\item original hypothesis about sbox:  SBox bad for correlation? the flash architecture -> bit block bit block bar
\item FUNDAMENTALLY A PROBLEM WITH DATA
\end{itemize}
\subsection{Caveats}
We address concerns and discuss the drawbacks for our chosen method of attack:
\begin{itemize}
    \item[--] We chose to attack the Arduino library's implementation AES-ECB mode. Althought ECB is not semantically secure (e.g. you can derive information about the plaintext from the ciphertext), ECB is still (unfortunately) used as the default option in a number of crypto-suites, \texttt{avr-crypto-lib} included. This is because of it's relatively simple implementation, compared to other more sophisticated modes of AES. Furthermore, our attack does not exploit the plaintext-ciphertext correlations in ECB to derive the key; rather, it uses our power sidechannel. For our team's first power-trace based attack, we chose a mode that we were confident that might have some correlation with the plaintext-key-guess XOR (the first computation in the first step of ECB). It might be possible to adapt our attack to CBC-mode as well.
- presence of trigger
- more
- go over the graphs, and timing/accuracy results of tests
\end{itemize}
\subsection{Overview of Source Code}
- overview everything in dropbox

\section{Results}

%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}


\section*{Acknowledgment}
The authors would like to extend our deepest thanks to Chiraag Juvekar of the Energy Efficient Digital Circuits group (where the authors work) for the time he spent with us aiding our debugging of data collection and analysis problems. We would also like to thank Albert Kwon, our TA, for his insightful advice over the course of the project.


\begin{thebibliography}{1}
\bibitem{ssl}
Lee, Homin K and Malkin, Tal and Nahum, Erich, \emph{Cryptographic strength of ssl/tls servers: current and recent practices}.\hskip 1em plus
  0.5em minus 0.4em\relax Proceedings of the 7th ACM SIGCOMM conference on Internet measurement, 2007.

\bibitem{kerberos}
Rathore, Romendrapal Singh and Pal, BL and Kumar, Shiv. \emph{Analysis and Improvement in Kerberos 5}.\hskip 1em plus
  0.5em minus 0.4em\relax 2015.

\bibitem{embedded}
Altera Corporation, \emph{FPGAs with built-in AES: The key to secure system designs}.\hskip 1em plus
  0.5em minus 0.4em\relax Embedded Computing Design, July 15, 2008.

\bibitem{smalldevice}
Oswald, Elisabeth, et al.  \emph{Side-Channel Analysis Resistant Description of the AES S-Box}.\hskip 1em plus 
  0.5em minus 0.4em\relax 2005.

\bibitem{AESLib}
    \url{https://github.com/DavyLandman/AESLib}. \emph{Arduino AESLib}. \hskip 1em plus
    0.5em minus 0.4em\relax 2015.

\bibitem{daslabor}
    \url{http://www.das-labor.org/wiki/AVR-Crypto-Lib/en}. \emph{AVR-Crypto-Lib}. \hskip 1em plus
    0.5em minus 0.4em\relax 2013.


\end{thebibliography}
\end{document}


